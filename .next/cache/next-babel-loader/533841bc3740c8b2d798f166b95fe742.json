{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport { Flex } from '@/components/container';\nimport { Left } from '@/components/svg';\nimport Button from '@/components/button';\nimport { concat } from '@/utils/component';\nimport { Context } from '@/utils/global';\nimport { scrollAnimation } from '@/utils/scroll';\nimport styles from './anchor.less';\nimport shadowStyles from '@/styles/shadow.less';\nexport default function Anchor(props) {\n  const {\n    content,\n    className,\n    indent = 10,\n    width = 275,\n    suffixAnchors: suffixAnchor = [],\n    container\n  } = props,\n        restProps = _objectWithoutProperties(props, [\"content\", \"className\", \"indent\", \"width\", \"suffixAnchors\", \"container\"]);\n\n  const ref = React.useRef();\n  const context = React.useContext(Context);\n  const anchors = React.useMemo(() => findAnchors(content).concat(suffixAnchor), [content, suffixAnchor]);\n  const [show, setShow] = React.useState(context.big_screen);\n  const syncScroll = React.useCallback(e => {\n    const target = e.target === document ? document.documentElement : e.target; // 同步浮框位置\n\n    if (!!ref.current) ref.current.style.top = `${target.scrollTop + 100}px`; // 获取当前阅读进度\n\n    const scrollTop = target.scrollTop;\n\n    for (var i = 0; i < anchors.length; i++) {\n      const el = document.getElementById(anchors[i].id);\n\n      if (!!el && el.getBoundingClientRect().top + document.documentElement.scrollTop > scrollTop) {\n        // 清除老的状态\n        const lastActive = ref.current.getElementsByClassName(styles.active);\n\n        for (var j = 0; j < lastActive.length; j++) {\n          if (lastActive[j].id !== `anchor-${anchors[i].id}`) {\n            lastActive[j].classList.remove(styles.active);\n          }\n        } // 设置新的状态\n\n\n        const anchorsEls = ref.current.getElementsByTagName('a');\n        const nowEl = anchorsEls[i];\n        nowEl.classList.add(styles.active); // 将对应的连接移入视窗中\n\n        const linksEls = ref.current.getElementsByClassName(styles.links);\n        const linkEl = linksEls.length > 0 ? linksEls[0] : undefined;\n        if (!linkEl) break;\n        const nowTop = nowEl.offsetTop;\n        const nowHeight = nowEl.offsetHeight;\n        if (nowTop < linkEl.scrollTop) scrollAnimation(linkEl, nowTop);else if (nowTop + nowHeight > linkEl.scrollTop + linkEl.clientHeight) scrollAnimation(linkEl, nowTop - linkEl.clientHeight + nowHeight);\n        break;\n      }\n    }\n  }, [ref]);\n  React.useEffect(() => {\n    const c = !!container ? container : document;\n\n    if (!!c) {\n      c.addEventListener('scroll', syncScroll);\n      return () => c.removeEventListener('scroll', syncScroll);\n    }\n  }, [container, syncScroll]);\n  return __jsx(\"div\", _extends({\n    ref: ref\n  }, restProps, {\n    className: concat(styles.anchor, show ? styles.show : '', className)\n  }), __jsx(Button, {\n    neumorphism: true,\n    className: concat(styles.button),\n    icon: __jsx(Left, {\n      className: styles.icon\n    }),\n    onClick: () => setShow(!show)\n  }), __jsx(Flex, {\n    direction: \"TB\",\n    subAxis: \"flex-start\",\n    wrap: false,\n    className: concat(styles.links, shadowStyles.neumorphism)\n  }, anchors.map(item => __jsx(\"a\", {\n    key: item.id,\n    id: `anchor-${item.id}`,\n    href: `#${item.id}`,\n    style: {\n      paddingLeft: (item.level - 1) * indent\n    },\n    title: item.name,\n    onClick: () => {\n      const el = document.getElementById(item.id);\n      if (!!el) scrollAnimation(!!container ? container : document.documentElement, el.getBoundingClientRect().top + window.pageYOffset);\n    }\n  }, item.name))));\n}\nexport function findAnchors(html) {\n  var re = new RegExp(`<h([1-6]) id=\"(.*)\">(.*)</h\\\\1>`, 'g');\n  var result_list = [];\n\n  do {\n    var result = re.exec(html);\n\n    if (result !== null) {\n      result_list.push({\n        id: `${result[2]}`,\n        name: result[3],\n        level: parseInt(result[1])\n      });\n    }\n  } while (result);\n\n  return result_list;\n}","map":null,"metadata":{},"sourceType":"module"}